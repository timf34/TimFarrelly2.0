---
/*  No props â€“ one global background  */
---

<div id="gradient-container" class="gradient-container"></div>

<script is:inline>
  // Load Three.js from CDN
  document.addEventListener('DOMContentLoaded', () => {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
    script.onload = initGradient;
    document.head.appendChild(script);

    function initGradient() {
      // Static palettes
      const palettes = {
        yellowy: [
          { position: 0.0, color: '#F5E48E' },
          { position: 0.3, color: '#FFCB8E' },
          { position: 0.6, color: '#FFAA88' },
          { position: 0.8, color: '#FF88AA' }
        ],
        peachy: [
          { position: 0.0, color: '#FFFFFF' },
          { position: 0.3, color: '#FFC0AB' },
          { position: 0.6, color: '#FFAA88' },
          { position: 0.8, color: '#FF9999' }
        ]
      };

      class GradientLightField {
        constructor(container) {
          this.options = {
            container,
            gradientColors: palettes.yellowy,
            aspectRatio: 2.0,
            verticalStretch: 0.4,
            horizontalWidth: 0.8,
            feather: 0.6,
            intensity: 1.1
          };

          this.scene = this.camera = this.renderer = this.mesh = this.material = null;
          this.isDisposed = false;
          this.init();
        }

        init() {
          const aspect = window.innerWidth / window.innerHeight;

          this.scene = new THREE.Scene();
          this.camera = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, 0.1, 100);
          this.camera.position.z = 1;

          this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          this.renderer.setPixelRatio(window.devicePixelRatio);
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          this.renderer.setClearColor(0x000000, 0);
          this.options.container.appendChild(this.renderer.domElement);

          this.createMaterial();
          this.mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(2 * aspect, 2),
            this.material
          );
          this.scene.add(this.mesh);

          window.addEventListener('resize', () => this.onResize());

          this.renderer.setAnimationLoop(() => this.renderer.render(this.scene, this.camera));
          this.startColourCycle();
        }

        createMaterial() {
          const stops = new Float32Array(this.options.gradientColors.length * 4);
          this.writeStops(this.options.gradientColors, stops);
          const numStops = this.options.gradientColors.length;

          const vert = `
            varying vec2 vUv;
            void main(){ vUv = uv; gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0); }
          `;

          const frag = `
            varying vec2 vUv;
            uniform float uIntensity, uVerticalStretch, uHorizontalWidth, uFeather, uAspectRatio, uDithering, uTime;
            const int numStops = ${numStops};
            uniform vec4 uGradientStops[${numStops}];

            float random(vec2 st){return fract(sin(dot(st,vec2(12.9898,78.233)))*43758.5453123);}
            float bayer(vec2 p){int x=int(mod(p.x,4.));int y=int(mod(p.y,4.));
              float[16] m=float[16](0.,8.,2.,10.,12.,4.,14.,6.,3.,11.,1.,9.,15.,7.,13.,5.);
              return m[x+y*4]/16.;}
            float blue(vec2 p,float t){
              return (.5*random(p+t*.1)+.3*random(p*2.-t*.2)+.2*random(p*4.+t*.3));
            }

            void main(){
              vec2 uv=vUv-.5; uv.x*=uAspectRatio;
              float v=uv.y/uVerticalStretch, h=uv.x/uHorizontalWidth;
              float dist=mix(length(vec2(h,v)), max(abs(h),abs(v)), .3);
              dist=smoothstep(0.,1.+uFeather,dist);

              vec3 col=vec3(0.);
              for(int i=0;i<numStops-1;i++){
                if(dist>=uGradientStops[i].w && dist<=uGradientStops[i+1].w){
                  float t=(dist-uGradientStops[i].w)/(uGradientStops[i+1].w-uGradientStops[i].w);
                  col = mix(uGradientStops[i].xyz, uGradientStops[i+1].xyz, t);
                }
              }
              if(dist<uGradientStops[0].w) col=uGradientStops[0].xyz;
              if(dist>uGradientStops[numStops-1].w) col=uGradientStops[numStops-1].xyz;

              col*=uIntensity;

              if(uDithering>0.){
                float d = uDithering<.5 ? bayer(gl_FragCoord.xy) : blue(gl_FragCoord.xy,uTime);
                col += (d*2.-1.)*uDithering*.15;
              }
              gl_FragColor=vec4(col,1.);
            }
          `;

          this.material = new THREE.ShaderMaterial({
            vertexShader: vert,
            fragmentShader: frag,
            transparent: true,
            uniforms: {
              uIntensity: { value: this.options.intensity },
              uVerticalStretch: { value: this.options.verticalStretch },
              uHorizontalWidth: { value: this.options.horizontalWidth },
              uFeather: { value: this.options.feather },
              uAspectRatio: { value: this.options.aspectRatio },
              uGradientStops: { value: stops },
              uDithering: { value: 0.0 },
              uTime: { value: 0.0 }
            }
          });
        }

        writeStops(src, dst) {
          src.forEach((s, i) => {
            const { r, g, b } = this.hexRgb(s.color);
            dst.set([r, g, b, s.position], i * 4);
          });
        }

        hexRgb(h) {
          return {
            r: parseInt(h.slice(1, 3), 16) / 255,
            g: parseInt(h.slice(3, 5), 16) / 255,
            b: parseInt(h.slice(5, 7), 16) / 255
          };
        }

        lerpColor(a, b, t) {
          const toInt = h => parseInt(h, 16);
          const ah = a.slice(1), bh = b.slice(1);
          const ar = toInt(ah.substr(0, 2)), ag = toInt(ah.substr(2, 2)), ab = toInt(ah.substr(4, 2));
          const br = toInt(bh.substr(0, 2)), bg = toInt(bh.substr(2, 2)), bb = toInt(bh.substr(4, 2));
          const rr = Math.round(ar + (br - ar) * t), rg = Math.round(ag + (bg - ag) * t), rb = Math.round(ab + (bb - ab) * t);
          const h = v => v.toString(16).padStart(2, '0');
          return `#${h(rr)}${h(rg)}${h(rb)}`;
        }

        onResize() {
          const a = window.innerWidth / window.innerHeight;
          this.camera.left = -a; this.camera.right = a; this.camera.updateProjectionMatrix();
          this.mesh.geometry.dispose();
          this.mesh.geometry = new THREE.PlaneGeometry(2 * a, 2);
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        }

        updateColors(arr) {
          this.options.gradientColors = arr;
          this.writeStops(arr, this.material.uniforms.uGradientStops.value);
          this.material.uniforms.uGradientStops.needsUpdate = true;
        }

        cycle = { 'order': ['yellowy', 'peachy'], idx: 0, dur: 3000, pause: 2000 };
        startColourCycle() {
          const from = palettes[this.cycle.order[this.cycle.idx]];
          const to = palettes[this.cycle.order[(this.cycle.idx + 1) % this.cycle.order.length]];
          const start = performance.now();

          const step = (now) => {
            if (this.isDisposed) return;
            const t = Math.min(1, (now - start) / this.cycle.dur);
            const mix = from.map((s, i) => ({ position: s.position, color: this.lerpColor(s.color, to[i].color, t) }));
            this.updateColors(mix);
            if (t < 1) requestAnimationFrame(step);
            else {
              this.cycle.idx = (this.cycle.idx + 1) % this.cycle.order.length;
              setTimeout(() => this.startColourCycle(), this.cycle.pause);
            }
          };
          requestAnimationFrame(step);
        }

        dispose() {
          this.isDisposed = true;
          this.renderer.setAnimationLoop(null);
          window.removeEventListener('resize', this.onResize);
          this.mesh.geometry.dispose();
          this.material.dispose();
          this.renderer.dispose();
        }
      }

      // Initialize once the DOM is ready
      new GradientLightField(document.getElementById('gradient-container'));
    }
  });
</script>

<style>
  .gradient-container{
    position:fixed;
    inset:0;
    z-index:-1;
    pointer-events:none;
  }
</style>